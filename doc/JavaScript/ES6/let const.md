# 关于这一系列文章

网上已经有大量的关于es6的教程和实战，特别是阮大神的<a href="">ECMAScript 6 入门</a>系列，非常系统的讲解了es6的知识点。自己在这里回顾完全是基于日常使用es6后的一次复盘，只有这样才会对es6有更深的理解，就像我们小学才开始写作文的时候，老师总是让我们多多读人家好的文章，多背一些名言名句。但是要想真正提高自己的写作能力还是只有不断得练习写作，同时把日常积累的知识点运用当中，我们的能力才能提高。我想编程也是同理，看别人优秀的代码，学习别人的思想再结合自己的理解这样才能真正的提高！因为是基于自己的理解与观点所以不敢保证100%的客观与正确，如有错误的地方还望指正。

## 关于es6

对于es6我们完全可看成是JavaScript（后面简称js）的一次查漏补缺，是为了补上当初诞生时的一些缺陷。所以你会发现es6的一些新东西在目前比较成熟的语言如java的身上能够看到很多。这也不能怪js，毕竟他的发明者Brendan Eich都没有想到js会像今天一样用途这么广泛！“一行js不能解决的问题，那就再写一行”

## let
为什么会有let，在es6之前的js中只有两个作用域，一个是全局作用域，一个是函数作用域。比如我在全局中声明一个变量：
```js
//我可以在全局中访问到a这个变量，虽然实际编程时不推荐这样做。
var a = 'window'
```
函数作用域：
```js
function fun(){
    //变量a只在函数内部起作用
    var a = "function"
}
```
你在Java中看到的块级作用域在js当中是没有的
```java
{
    //块级作用域
}
```
现在我们来看看let能干什么，我们先使用var来申明一个变量，并运行
```js
function count(){
    for(var i=1;i<2;i++){
        console.log(i)
    }
    console.log(i)
}
count()//打印的结果为1 2
```
但是当你使用let来申明i时
```js
function count(){
      for(let i=1;i<2;i++){
        console.log(i)
    }
    console.log(i)
}
count()//打印的结果为1 Uncaught ReferenceError: i is not defined
}
```
造成这样的结果就是let声明的变量只在他的{ }中起效果，外部是无法访问的。并且因为es6是强制开启**严格模式**，不允许我们没有申请变量而使用。所以我们的报错类型为"ReferenceError"

## const
我们在es6中可以使用const关键字申明一个常量，常量一旦申明既不能更改。
```js
const change = 'a';
change = 'b';
//Assignment to constant variable.(浏览器将会报错，将变量赋值给常量)
```
但是这样并不是绝对的，我们再来看一种情况
```js
const obj = {
    name:'jack'
}
obj.year = '2018'
console.log(obj)
//可以看到并没有报错，浏览器打印出了我们想要的结果
//{name: "jack", year: "2018"}
```
为什么会这样？不是申明就不能改变吗？解答这个问题之前我们先来看看这个例子
```js
console.log(Boolean({} == {}))
//false
```
原理很简单，这里比较的不是对象的本身而是存放在内存中指向对象的指针，也可以说是地址，两个不同的对象存放的地址可能一样吗？所以这里我们得到是false。回到上面的问题obj存放的只是对象的在内存中得指针，我们改变的对象内部的属性并不会影响它在内存中的指针，所以我们可以得到我们想要的结果{name: "jack", year: "2018"}

同时在块级作用域上const与let是一样的，现在我们再来看另一种情况
```js
const change;
change = 'a'
//Missing initializer in const declaration 
```
const必须申明即赋值。

最后，我们有时在看webpack配置文件的时候就会发现，一些插件的引入就是通过const来申明的，这样一来就可以防止我们在后续的编码过程中重新申明模块名而导致错误。



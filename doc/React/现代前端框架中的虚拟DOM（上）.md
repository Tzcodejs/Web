现代前端框架都会引入虚拟DOM的概念，不管是react还是新秀vue，虚拟DOM都起到了重要作用。我们先来说结论：
1. 提高前端DOM性能。
2. 使多端开发成为可能。

先说前端性能问题，要问浏览器中什么最耗性能？那一定是操作DOM元素，因为浏览器的渲染机制（这部分不展开说明），大量高频率操作DOM元素是非常大的一笔性能开销。那么虚拟DOM又是如何解决这个问题的呢？我们先来模拟一个虚拟场景。（下面的实例不局限于react或是vue）

## 方法一

这是我们的html结构
```html
<div id="hello">
    <p>this.state.value</p>
</div>
```
我的数据来源
```js
state = {
    value:'hello'
}
```
在没有使用虚拟DOM时，我们要改变p元素中的值应该如何来做呢？这里假设html结构还未被创建，那么应该是这样一个流程。

1. 初始化state数据。
2. 初始化dom模板。
3. 数据+模板生成DOM结构，浏览器打印显示。
4. 数据发生改变，重复以上过程。
5. 数据+模板生成DOM替换原始DOM，从而实现数据更新。

那么这样的渲染方法有什么缺点呢？我们将缺陷总结如下：
- 第一次生成了一个dom片段。
- 第二次生成了一个全新的dom片段。
- 第二次的dom片段与第一次的dom片段相替换。（这一步相当的耗费性能）

所以我们继续优化......

## 方法二

还是上面的结构。

1. 初始化state数据。
2. 初始化dom模板。
3. 数据+模板生成DOM结构，浏览器打印显示。
4. 数据发生改变，重复以上过程。
5. 数据+模板生成DOM，但不直接替换。
6. 新旧DOM通过（documentFragment）对比差异。
7. 只替换变化的DOM。

这一次我们并没有完全替换旧的DOM，而是对比差异只替换变化部分。但是这样的做法并没有让性能有较大提升，虽然只替换了差异部分，但是新旧DOM的对比还是会耗费一部分性能。

## 方法三

我们正式引入虚拟DOM

1. 初始化state数据。
2. 初始化dom模板。
3. 生成虚拟DOM（虚拟DOM就是一个js对象，以上面的html结构为例，将会被转化为）
```js
['div',{id:'hello'},['span',{},'hello']]
```
4. 数据+模板生成DOM结构，浏览器打印显示。
5. 数据发生改变。
6. 生成新的虚拟DOM。
7. 对比js的两个对象的差异。
8. 只替换变化的DOM，改变内容。

这样一来，dom之间的对比将会转化为两个js对象之间的对比，并且高频率的DOM改变只会引发一次DOM变动，有点那么函数节流的意思，所以虚拟DOM的引入带来的性能提升是很可观的。

我们回到react中的render函数来看

这是我们日常的写法
```js

render(){
    return (
        <div>hello</div>
    )
}
```
我们可以转变成这样
```js

render(){
    return React.createElement('div',{/*这里是div的属性值，类似id、class*/},'hello')
}
```
所以在react中，渲染流程应该是这样的：

JSX模板 &rarr; createElement &rarr; 虚拟DOM（js对象）&rarr; 真实DOM

最后我们来回答，为什么虚拟DOM的引入可以让开发跨平台应用得以实现。在浏览器的环境下虚拟DOM映射的是浏览器DOM树，而如果是跨平台诸如React Native，那么虚拟DOM映射的就是原生控件树。这也是为什么如今跨平台开发如雨后春笋般蓬勃发展的原因。

PS：如果你使用过React Native开发应用，你会发现当页面涉及大量DOM改变时依然会存在一定性能问题。因为虚拟DOM映射原生控件树的过程中的性能损耗也是不可避免的。因此，出现了另外一种跨端解决方案，通过自己的一套渲染引擎绘与UI布局系统，体验几乎与原生接近。这就是google最新推出的<a href="https://flutterchina.club/">flutter</a>，据说可以达到120fps的效果！

